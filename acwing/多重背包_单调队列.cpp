/*
* Author:czj
* Time  :2019/12/14 10:50
* Email :zj_cheng@csu.edu.cn
有 N 种物品和一个容量是 V 的背包。
第 i 种物品最多有 si 件，每件体积是 vi，价值是 wi。
求解将哪些物品装入背包，可使物品体积总和不超过背包容量，且价值总和最大。
输出最大价值。

输入格式
第一行两个整数，N，V (0<N≤1000, 0<V≤20000)，用空格隔开，分别表示物品种数和背包容积。
接下来有 N 行，每行三个整数 vi,wi,si，用空格隔开，分别表示第 i 种物品的体积、价值和数量。
输出格式
输出一个整数，表示最大价值。

数据范围
0<N≤1000
0<V≤20000
0<vi,wi,si≤20000
提示
本题考查多重背包的单调队列优化方法。
*/
/**
 * 单调队列复习：   a = [1, 3, -1, -3, 5, 3, 6, 7]
 * 考虑这么一个数组： 我们需要求 k=3 的连续片段中的最大值， 即[1,3,-1],[3,-1,-3]....[3,6,7]  不同段最大值，最后的最大值
 * 1.  直接遍历每一个下标 i,  计算[i-k,..., i]的最大值，  这样的时间复杂度  O(N*k)
 *
 * 2.  方法1中存在的冗余是什么？   计算 [1,3,-1] 我们会得到最大值 3, 此时 -1比较了 1,3。 同样的在计算 [3,-1,-3]时候， 我们将使用-3 去比较
 *      -1,3。  然而在前一个片段中， -1已经与3比较了， 这里我们只需要比较 -3与他们中最大的一个就可以。
 *
 *      单调队列的思想（递增）：  每一位置都有一个（id, val）的二元组， 载满足递增的情况下，  我们需要得到 id,val都很大的，删除id,val较小的，例如刚才
 *      -3在向前比较的时候只需要比较3位置就可以了。
 *
 * 这个例子的具体解法：（出队列， 入对列的比较）
 * 区间（由k控制）           (id,val)二元组
 * [1,3]                  (1,1)
 * [1,3]                  删除(1,1), 加入(2,3)
 * [1,3]                   (2,3),(3,-1)
 * [2,4]                   (2,3),(3,-1),(4,-3)
 * [3,5]                   2大于3这个id区间，  (5,5)
 * [4,6]                    (5,5),(6,3)
 * [5,7]                    (7,6)
 * [6,8]                    (8,7)
 *
 * 该题目的解题思路：
 * 对于一个新来的物品 i, 可以得到 件数 s, 体积 v, 价值 w,   背包的总的体积为 V
 * f[i][0...V]表示前i个物品中，背包体积为0...V时候能够获得的最大价值
 *
 * f[i][d] = f[i-1][d]
 * f[i][d+v] = max(f[i-1][d]+w, f[i-1][d+v])
 * f[i][d+2v] = max(f[i-1][d]+2w, f[i-1][d+v]+w, f[i-1][d+2v])
 * f[i][d+3v] = max(f[i-1][d]+3w, f[i-1][d+v]+2w, f[i-1][d+2v]+w, f[i][d+3v])
 *
 * 转化为
 * f[i][d] = f[i-1][d]
 * f[i][d+v] = max(f[i-1][d], f[i-1][d+v]-w)    +w
 * f[i][d+2v] = max(f[i-1][d], f[i-1][d+v]-w, f[i-1][d+2v]-2w) + 2w
 * f[i][d+3v] = max(f[i-1][d], f[i-1][d+v]-w, f[i-1][d+2v]-2w, f[i-1][d+3v]-3w)  +3w
 *
 * 这样就转化为了单调递增队列的形式。其中 d表示  j/v 能够达到的余数。
 */
#include <iostream>
#include <algorithm>
using namespace std;

int f[10001][20001];
int queue[20005];
int num[20005];
int main() {
    int N, V;
    cin>>N>>V;
    for(int i=1; i<=N; i++){
        int v, w, s;
        cin>>v>>w>>s;
        for(int d=0; d<v; d++){
            int head = 0, tail=-1;
            for(int j=0; j<=(V-d)/v; j++){
                int tmp = f[i-1][d+j*v]-j*w;
                while(head<=tail && j-num[head]>s) head++;
                while(head<=tail && tmp>queue[tail]) tail--;
                queue[++tail] = tmp;
                num[tail] = j;
                f[i][d+j*v] = queue[head]+j*w;
            }
        }
    }
    cout<<f[N][V];
    return 0;
}


