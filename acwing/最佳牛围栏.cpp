/*
* Author:czj
* Time  :2019/12/24 13:38
* Email :zj_cheng@csu.edu.cn
农夫约翰的农场由 N 块田地组成，每块地里都有一定数量的牛,其数量不会少于1头，也不会超过2000头。

约翰希望用围栏将一部分连续的田地围起来，并使得围起来的区域内每块地包含的牛的数量的平均值达到最大。

围起区域内至少需要包含 F 块地，其中 F 会在输入中给出。

在给定条件下，计算围起区域内每块地包含的牛的数量的平均值可能的最大值是多少。

输入格式
第一行输入整数 N 和 F ，数据间用空格隔开。

接下来 N 行，每行输出一个整数，第i+1行输出的整数代表，第i片区域内包含的牛的数目。

输出格式
输出一个整数，表示围起区域内每块地包含的牛的数量的平均值可能的最大值乘以1000得到的数值。

数据范围
1≤N≤100000
1≤F≤N
输入样例：
10 6
6
4
2
10
3
8
5
9
4
1
输出样例：
6500
*/
/*
首先题目题目一上来就描述了，  每个位置的牛的个数是（1,2000）之间，那么最后的平均值，肯定也是（1,2000）之间，
 这其实在提醒我们使用二分查找的方式去做

 使用二分查找解决问题的时候需要考虑的两个问题：
 1. 题目是否满足  求解问题下很难  然而转为判定问题就很简单
 显然，直接去求解这个最大的平均值很难，  然而如果给出 一个平均值x,  我们判断是否存在一个子段和平均值为x很简单
 2. 题目描述的问题是否具有单调性（这样的化，我们才可以更加二分条件不断去缩减区间）
 显然，如果存在一个 子段平均值为x,  一定也存在子段平均值 小于x,  然而如果子度平均值最大为x, 一定不存在还有子段平均
 值大于x.  即满足单调性

 因此，问题变为  给定 假设的平均值x, 不断去判定是否存在这样一个子段大于F长度的平均值为 x;
 本问题的另外一个技巧就是  初始化的时候,对于给定的 x,  所有元素减去平均值 x。
 然后求解前缀和 sum[i],  使用双指针，使得我们不用去遍历一次F, 因为我们只需要子段的长度大于F,  不需要确定的字段长度。
 寻找满足条件的  sum[j] - sum[i]  j-i>F   然后（sum[j]-sum[i]）>0 就可以认为可以找到这样一个平均值 x。
*/
//有问题欢迎大家交流指导，学习
#include <iostream>
#include <algorithm>
using namespace std;
int N, F;
double sum[100010];
int a[100010];
bool check(double x){
    for(int i=1; i<=N; i++)
        sum[i] = sum[i-1] + a[i] - x;

    double mint = 0;
    for(int i=0, j=F; j<=N; i++, j++){
        mint = min(mint, sum[i]);
        if(sum[j] >= mint)
            return true;
    }
    return false;
}
int main(){
    cin>>N>>F;
    for(int i=1; i<=N; i++) cin>>a[i];
    double l=0, r=2000;
    while(r-l>1e-5){
        double mid = (l+r)/2;
        if(check(mid))
            l = mid;
        else
            r = mid;
    }
    cout<<(int)(l*1000)<<endl;
    return 0;
}