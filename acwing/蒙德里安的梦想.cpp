/*
* Author:czj
* Time  :2019/12/21 12:20
* Email :zj_cheng@csu.edu.cn
link: https://www.acwing.com/problem/content/293/
求把N*M的棋盘分割成若干个1*2的的长方形，有多少种方案。
例如当N=2，M=4时，共有5种方案。当N=2，M=3时，共有3种方案。
如下图所示：
输入格式
输入包含多组测试用例。
每组测试用例占一行，包含两个整数N和M。
当输入用例N=0，M=0时，表示输入终止，且该用例无需处理。
输出格式
每个测试用例输出一个结果，每个结果占一行。
数据范围
1≤N,M≤11
输入样例：
1 2
1 3
1 4
2 2
2 3
2 4
2 11
4 11
0 0
*/
/**
 * 解题思路：  首先可以看到 N, M 的范围都很小， 可能的求解思路就是  状态压缩DP
 *
 * 分析一下题目的意思，  对于某一行，我们只需要填充 1x2的格子多个，  然后剩下的位置肯定可以由 2x1的格子，也就是我们只需要考虑 2x1的格子在某
 * 一行中是怎么占据的就可以了。在这个过程中我们需要满足的要求是什么呢
 * 1.  2x1 的格子在 第 i行的某些位置填充好以后， 剩下的连续的空位置必须都是 2 的整数倍，  因为剩下的位置我们会用 1x2的格子去填充满
 * 该行。
 * 2.  这些在 第 i行 某些位置填充的 2x1的格子以后， 在i+1行 对应位置就不可以在填充 2x1的格子了，  这个画个图就可以想到了，应为上一个i行的位置
 * 对应位置填充过 2x1, 那么这个位置也是影响了 i+1 行这个位置的
 *
 * 由此可以定义状态：  f[i][j]  表示第 i行 在j这个状态填充格子的情况下，  总的合法方案数目。
 * 比如 j = (10011)(2进制) = (19)(10进制)  表示的就是会在 1,4,5 位置填充上 2x1的格子， j是一个满足 合法条件1 的状态
 *
 * 那么转移方程  f[i][j] =  sum( f[i-1][k])  k=0... (满足条件1,2的合法状态个数)
 *
 * 初始化 dp[0][0]=1 表示在空棋盘下的 一个方案
 * 结果   dp[N][0]  表示刚好一行，不可以再有一个位置  会放 2x1的这个状态的方案树
 *
 * 二. 如何满足条件 1,2
 * 1, 对于一个状态的二进制表示，其某一个二进制位为 1, 表示该位置放了 2x1的格子。
 *    连续为0的位置的连续个数都是偶数，则满足条件1
 * 2. 对于第 i-1行的状态k,  第i行状态 j，   j&k==0  并且  j|k的连续为0的位置也都是偶数，  则满足条件2
 */
#include <iostream>
#include <algorithm>
#include <vector>
#include <cstring>
using namespace std;

typedef long long LL;
int N, M;

LL f[12][1<<11];
bool st[1<<11];
vector<int> state[1<<11];

int main(){
    while(cin>>N>>M, N||M){

        //保存连续0为偶数的合法状态
        for(int i=0; i< 1<<M; i++){
            bool is_val = true;
            int cnt = 0;
            for(int j=0; j<M; j++){
                if(i>>j & 1){
                    if(cnt & 1){
                        is_val = false;
                        break;
                    }
                    cnt = 0;
                }else{
                    cnt++;
                }
            }
            if(cnt & 1) is_val = false;
            st[i] = is_val;
        }

        //判断 j,k两个前后之间的状态是否是合法的，并保存下来
        for(int i=0; i< 1<<M; i++){
            state[i].clear();
            for(int j=0; j< 1<<M; j++){
                if( !(i&j) && st[i|j])
                    state[i].push_back(j);
            }

        }

        //初始化状态数组
        memset(f, 0, sizeof(f));
        f[0][0] = 1;
        //完成递推式
        for(int i=1; i<=N; i++){
            for(int j=0; j< 1<<M; j++){
                for(auto k:state[j]){
                    f[i][j] += f[i-1][k];
                }
            }
        }
        cout<<f[N][0]<<endl;
    }
    return 0;
}
